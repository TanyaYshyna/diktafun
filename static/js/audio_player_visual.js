/**
 * AudioPlayerVisual - Визуальный компонент для отображения состояния аудио плеера
 * Отрисовывает: кнопку play/pause, прогресс-бар, время, длительность, тип аудио, скорость
 */
class AudioPlayerVisual {
    constructor(containerElement, options = {}) {
        this.container = containerElement;
        
        // Элементы DOM
        this.playButton = null;
        this.currentTimeElement = null;
        this.progressBar = null;
        this.totalTimeElement = null;
        this.audioTypeSelect = null;
        this.audioTypeDisplay = null;
        this.speedSelect = null;
        this.speedDisplay = null;

        // Состояние
        this.currentAudioType = 'o'; // o, a, f, m
        this.audioPaths = {
            o: null, // original (audio)
            a: null, // autogenerated (audio_a)
            f: null, // file (audio_f)
            m: null  // microphone (audio_m)
        };
        this.isPlaying = false;
        this.currentTime = 0;
        this.duration = 0;
        this.playbackRate = 1.0;
        this.audioElement = null; // Ссылка на audio элемент для синхронизации
        this.syncAnimationFrame = null; // requestAnimationFrame ID для синхронизации

        // Callbacks
        this.onPlayClick = null;
        this.onAudioTypeChange = null;
        this.onSpeedChange = null;
        this.onProgressSeek = null;

        // Опции
        this.options = {
            speedOptions: [0.5, 0.75, 0.9, 1],
            progressBarMinWidth: 150,  // Минимальная ширина прогресс-бара в px
            progressBarMaxWidth: 200,  // Максимальная ширина прогресс-бара в px
            progressBarWidth: 150,     // Начальная ширина прогресс-бара в px
            ...options
        };

        this.init();
    }

    /**
     * Инициализация компонента
     */
    init() {
        if (!this.container) {
            throw new Error('Container element is required');
        }

        this.render();
        this.setupEventListeners();
    }

    /**
     * Рендеринг HTML структуры
     */
    render() {
        this.container.innerHTML = `
            <div class="controls">
                <span id="language" style="color: var(--color-button-text-yellow, #fbbf24); font-size: 20px; font-weight: 800; margin-right: 0; min-width: 40px;"></span>
                <button class="play-btn">
                    <i data-lucide="play"></i>
                </button>
                <input type="range" class="progress-bar" min="0" max="100" value="0" style="position: relative; min-width: ${this.options.progressBarMinWidth}px; max-width: ${this.options.progressBarMaxWidth}px; width: ${this.options.progressBarWidth}px;">
                <span class="total-time">0:00</span>
                <div class="audio-type-select-wrapper" style="position: relative; display: inline-block; vertical-align: middle;">
                    <button class="audio-type-select-button" style="border: 1px solid #ddd; padding: 3px 12px; border-radius: 4px; background: white; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 20px; font-weight: 800; vertical-align: middle;">
                        <span class="audio-type-display" style="color: var(--color-button-text-yellow, #fbbf24); font-weight: 500;">o</span>
                        <i data-lucide="chevron-down" class="audio-type-arrow" style="width: 14px; height: 14px;"></i>
                    </button>
                    <ul class="audio-type-options" style="display: none; list-style: none; padding: 0; margin: 0; position: absolute; bottom: 100%; background: white; border: 1px solid #ddd; border-radius: 4px; width: max-content; min-width: 100%; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; margin-bottom: 4px; max-height: 200px; overflow-y: auto; white-space: nowrap;">
                        <li data-value="o" class="selected" style="padding: 8px 12px; cursor: pointer; font-size: 16px; border-bottom: 1px solid #eee; transition: background 0.2s; white-space: nowrap;">o - по умолчанию</li>
                        <li data-value="a" style="padding: 8px 12px; cursor: pointer; font-size: 16px; border-bottom: 1px solid #eee; transition: background 0.2s; white-space: nowrap;">a - автоозвучка</li>
                        <li data-value="f" style="padding: 8px 12px; cursor: pointer; font-size: 16px; border-bottom: 1px solid #eee; transition: background 0.2s; white-space: nowrap;">f - из файла</li>
                        <li data-value="m" style="padding: 8px 12px; cursor: pointer; font-size: 16px; transition: background 0.2s; white-space: nowrap;">m - запись</li>
                    </ul>
                </div>
                <div class="custom-speed-select" style="position: relative; display: inline-block; vertical-align: middle;">
                    <button class="speed-select-button" style="border: 1px solid #ddd; padding: 3px 12px; border-radius: 4px; background: white; cursor: pointer; display: flex; align-items: center; gap: 6px; font-size: 20px; vertical-align: middle;">
                        <span class="speed-selected">1×</span>
                        <i data-lucide="chevron-down" class="speed-arrow" style="width: 14px; height: 14px;"></i>
                    </button>
                    <ul class="speed-options" style="display: none; list-style: none; padding: 0; margin: 0; position: absolute; bottom: 100%; background: white; border: 1px solid #ddd; border-radius: 4px; min-width: 80px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 1000; margin-bottom: 4px; max-height: 200px; overflow-y: auto;">
                        ${this.options.speedOptions.map((rate, index) => 
                            `<li data-value="${rate}" ${rate === 1 ? 'class="selected"' : ''} style="padding: 8px 12px; cursor: pointer; font-size: 16px; ${index < this.options.speedOptions.length - 1 ? 'border-bottom: 1px solid #eee;' : ''} transition: background 0.2s;">${rate}×</li>`
                        ).join('')}
                    </ul>
                </div>
            </div>
        `;

        // Сохраняем ссылки на элементы
        this.playButton = this.container.querySelector('.play-btn');
        this.progressBar = this.container.querySelector('.progress-bar');
        this.totalTimeElement = this.container.querySelector('.total-time');
        this.audioTypeSelect = this.container.querySelector('.audio-type-select-wrapper');
        this.audioTypeDisplay = this.container.querySelector('.audio-type-display');
        this.speedSelect = this.container.querySelector('.custom-speed-select');
        this.speedDisplay = this.container.querySelector('.speed-selected');

        // Инициализируем иконки Lucide
        if (typeof lucide !== 'undefined' && lucide && typeof lucide.createIcons === 'function') {
            lucide.createIcons();
        }
    }

    /**
     * Настройка обработчиков событий
     */
    setupEventListeners() {
        // Кнопка play/pause
        if (this.playButton) {
            this.playButton.addEventListener('click', () => {
                if (this.onPlayClick) {
                    this.onPlayClick();
                }
            });
        }

        // Прогресс-бар (перемотка)
        if (this.progressBar) {
            this.progressBar.addEventListener('input', (e) => {
                const percent = parseFloat(e.target.value);
                const time = (percent / 100) * this.duration;
                if (this.onProgressSeek) {
                    this.onProgressSeek(time);
                }
            });
        }

        // Получаем ссылки на оба выпадающих списка заранее
        const audioTypeButton = this.audioTypeSelect?.querySelector('.audio-type-select-button');
        const audioTypeOptions = this.audioTypeSelect?.querySelector('.audio-type-options');
        const speedButton = this.speedSelect?.querySelector('.speed-select-button');
        const speedOptions = this.speedSelect?.querySelector('.speed-options');
        
        // Выбор типа аудио
        if (audioTypeButton && audioTypeOptions) {
            audioTypeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const isVisible = audioTypeOptions.style.display !== 'none';
                audioTypeOptions.style.display = isVisible ? 'none' : 'block';
                // Закрываем другой выпадающий список при открытии этого
                if (!isVisible && speedOptions) {
                    speedOptions.style.display = 'none';
                }
            });

            // Закрытие при клике вне
            document.addEventListener('click', (e) => {
                if (!this.audioTypeSelect.contains(e.target)) {
                    audioTypeOptions.style.display = 'none';
                }
            });

            // Выбор опции с hover-эффектом
            audioTypeOptions.querySelectorAll('li').forEach(li => {
                li.addEventListener('mouseenter', () => {
                    li.style.background = '#f5f5f5';
                });
                li.addEventListener('mouseleave', () => {
                    li.style.background = 'white';
                });
                li.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = li.dataset.value;
                    if (value && this.audioPaths[value]) {
                        this.setAudioType(value);
                        audioTypeOptions.style.display = 'none';
                        if (this.onAudioTypeChange) {
                            this.onAudioTypeChange(value, this.audioPaths[value]);
                        }
                    }
                });
            });
        }

        // Выбор скорости
        if (speedButton && speedOptions) {
            speedButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const isVisible = speedOptions.style.display !== 'none';
                speedOptions.style.display = isVisible ? 'none' : 'block';
                // Закрываем другой выпадающий список при открытии этого
                if (!isVisible && audioTypeOptions) {
                    audioTypeOptions.style.display = 'none';
                }
            });

            // Закрытие при клике вне
            document.addEventListener('click', (e) => {
                if (!this.speedSelect.contains(e.target)) {
                    speedOptions.style.display = 'none';
                }
            });

            // Выбор скорости с hover-эффектом
            speedOptions.querySelectorAll('li').forEach(li => {
                li.addEventListener('mouseenter', () => {
                    li.style.background = '#f5f5f5';
                });
                li.addEventListener('mouseleave', () => {
                    li.style.background = 'white';
                });
                li.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const value = parseFloat(li.dataset.value);
                    this.setPlaybackRate(value);
                    speedOptions.querySelectorAll('li').forEach(l => l.classList.remove('selected'));
                    li.classList.add('selected');
                    speedOptions.style.display = 'none';
                    if (this.onSpeedChange) {
                        this.onSpeedChange(value);
                    }
                });
            });
        }
    }

    /**
     * Установить пути к аудио файлам
     * @param {Object} paths - Объект с путями {audio: 'path', audio_a: 'path', audio_f: 'path', audio_m: 'path'}
     */
    setAudioPaths(paths) {
        this.audioPaths = {
            o: paths.audio || null,  // original
            a: paths.audio_a || null,
            f: paths.audio_f || null,
            m: paths.audio_m || null
        };

        // Обновляем доступные опции в выпадающем списке
        this.updateAudioTypeOptions();
        
        // Устанавливаем тип по умолчанию (если текущий недоступен, используем o)
        if (!this.audioPaths[this.currentAudioType]) {
            this.currentAudioType = 'o';
        }
        this.updateAudioTypeDisplay();
    }

    /**
     * Обновить доступные опции типа аудио
     */
    updateAudioTypeOptions() {
        const options = this.audioTypeSelect?.querySelector('.audio-type-options');
        if (!options) return;

        options.querySelectorAll('li').forEach(li => {
            const value = li.dataset.value;
            if (!this.audioPaths[value]) {
                li.style.display = 'none';
            } else {
                li.style.display = 'list-item';
                if (value === this.currentAudioType) {
                    li.classList.add('selected');
                } else {
                    li.classList.remove('selected');
                }
            }
        });
    }

    /**
     * Установить текущий тип аудио
     * @param {string} type - 'o', 'a', 'f' или 'm'
     */
    setAudioType(type) {
        if (!this.audioPaths[type]) {
            console.warn(`Audio type ${type} is not available`);
            return;
        }

        this.currentAudioType = type;
        this.updateAudioTypeDisplay();
        
        // Обновляем выбранную опцию
        const options = this.audioTypeSelect?.querySelector('.audio-type-options');
        if (options) {
            options.querySelectorAll('li').forEach(li => {
                if (li.dataset.value === type) {
                    li.classList.add('selected');
                } else {
                    li.classList.remove('selected');
                }
            });
        }
    }

    /**
     * Получить текущий тип аудио
     * @returns {string}
     */
    getAudioType() {
        return this.currentAudioType;
    }

    /**
     * Получить путь к текущему аудио файлу
     * @returns {string|null}
     */
    getCurrentAudioPath() {
        return this.audioPaths[this.currentAudioType] || this.audioPaths.o;
    }

    /**
     * Обновить отображение типа аудио
     */
    updateAudioTypeDisplay() {
        if (this.audioTypeDisplay) {
            this.audioTypeDisplay.textContent = this.currentAudioType.toLowerCase();
        }
    }

    /**
     * Установить состояние воспроизведения
     * @param {boolean} isPlaying
     */
    setPlaying(isPlaying) {
        this.isPlaying = isPlaying;
        if (this.playButton) {
            const icon = this.playButton.querySelector('[data-lucide]');
            if (icon) {
                icon.setAttribute('data-lucide', isPlaying ? 'pause' : 'play');
                if (typeof lucide !== 'undefined' && lucide && typeof lucide.createIcons === 'function') {
                    lucide.createIcons();
                }
            }
        }
        
        // Запускаем/останавливаем синхронизацию через requestAnimationFrame
        if (isPlaying && this.audioElement) {
            this.startSync();
        } else {
            this.stopSync();
        }
    }
    
    /**
     * Установить ссылку на audio элемент для синхронизации
     * @param {HTMLAudioElement} audioElement
     */
    setAudioElement(audioElement) {
        this.audioElement = audioElement;
        // Если уже играет, запускаем синхронизацию
        if (this.isPlaying && audioElement) {
            this.startSync();
        }
    }
    
    /**
     * Запустить синхронизацию бигунка через requestAnimationFrame
     */
    startSync() {
        if (!this.audioElement) return;
        this.stopSync(); // Останавливаем предыдущую синхронизацию если есть
        
        const update = () => {
            if (this.audioElement && !this.audioElement.paused && !this.audioElement.ended) {
                const currentTime = this.audioElement.currentTime || 0;
                const duration = this.audioElement.duration || 0;
                this.updateTime(currentTime, duration);
                this.syncAnimationFrame = requestAnimationFrame(update);
            } else {
                this.stopSync();
            }
        };
        this.syncAnimationFrame = requestAnimationFrame(update);
    }
    
    /**
     * Остановить синхронизацию бигунка
     */
    stopSync() {
        if (this.syncAnimationFrame) {
            cancelAnimationFrame(this.syncAnimationFrame);
            this.syncAnimationFrame = null;
        }
    }

    /**
     * Обновить текущее время и прогресс
     * @param {number} currentTime - Текущее время в секундах
     * @param {number} duration - Длительность в секундах
     */
    updateTime(currentTime, duration) {
        this.currentTime = currentTime || 0;
        this.duration = duration || 0;

        // Обновляем отображение общей длительности
        if (this.totalTimeElement) {
            this.totalTimeElement.textContent = this.formatTime(this.duration);
        }

        // Обновляем прогресс-бар
        if (this.progressBar && this.duration > 0) {
            const percent = (this.currentTime / this.duration) * 100;
            this.progressBar.value = percent;
        }
    }

    /**
     * Установить скорость воспроизведения
     * @param {number} rate
     */
    setPlaybackRate(rate) {
        this.playbackRate = rate;
        if (this.speedDisplay) {
            this.speedDisplay.textContent = `${rate}×`;
        }
    }

    /**
     * Получить текущую скорость воспроизведения
     * @returns {number}
     */
    getPlaybackRate() {
        return this.playbackRate;
    }

    /**
     * Установить язык
     * @param {string} lang
     */
    setLanguage(lang) {
        const langElement = this.container.querySelector('#language');
        if (langElement) {
            langElement.textContent = lang || '';
        }
    }

    /**
     * Форматировать время в формат MM:SS
     * @param {number} seconds
     * @returns {string}
     */
    formatTime(seconds) {
        if (!isFinite(seconds) || isNaN(seconds)) return '0:00';
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }

    /**
     * Установить callback для клика по play
     */
    setOnPlayClick(callback) {
        this.onPlayClick = callback;
    }

    /**
     * Установить callback для изменения типа аудио
     */
    setOnAudioTypeChange(callback) {
        this.onAudioTypeChange = callback;
    }

    /**
     * Установить callback для изменения скорости
     */
    setOnSpeedChange(callback) {
        this.onSpeedChange = callback;
    }

    /**
     * Установить callback для перемотки
     */
    setOnProgressSeek(callback) {
        this.onProgressSeek = callback;
    }

    /**
     * Сброс состояния
     */
    reset() {
        this.stopSync();
        this.setPlaying(false);
        this.updateTime(0, 0);
        this.audioElement = null;
    }
}

